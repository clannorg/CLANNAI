// This file is auto-generated by @hey-api/openapi-ts

/**
 * Base entity with common fields
 */
export type BaseEntity = {
    /**
     * Unique identifier for the entity
     */
    id?: string;
    /**
     * Timestamp when the entity was created
     */
    createdAt?: string;
    /**
     * Timestamp when the entity was last updated
     */
    updatedAt?: string;
};

export type UserScopedEntity = BaseEntity & {
    /**
     * Username of the user who created this entity
     */
    createdBy: string;
};

/**
 * Base DynamoDB item structure with all required keys
 */
export type DynamoDbItem = {
    /**
     * DynamoDB Partition Key
     */
    PK: string;
    /**
     * DynamoDB Sort Key
     */
    SK: string;
    /**
     * Global Secondary Index 1 Partition Key
     */
    GSI1PK: string;
    /**
     * Global Secondary Index 1 Sort Key
     */
    GSI1SK: string;
    /**
     * Global Secondary Index 2 Partition Key (optional for global entities)
     */
    GSI2PK?: string;
    /**
     * Global Secondary Index 2 Sort Key (optional for global entities)
     */
    GSI2SK?: string;
    /**
     * Global Secondary Index 3 Partition Key (optional)
     */
    GSI3PK?: string;
    /**
     * Global Secondary Index 3 Sort Key (optional)
     */
    GSI3SK?: string;
    /**
     * Type of entity for filtering
     */
    entityType: string;
};

export type UserScopedDbItem = DynamoDbItem & {
    PK?: unknown;
    GSI2PK: unknown;
    GSI2SK: unknown;
};

export type GlobalDbItem = DynamoDbItem & {
    PK?: unknown;
};

export type User = BaseEntity & {
    /**
     * Unique username from Cognito
     */
    username: string;
    /**
     * User email address
     */
    email: string;
    /**
     * User's first name
     */
    firstName: string;
    /**
     * User's last name
     */
    lastName: string;
    /**
     * User role in the system
     */
    role: 'player' | 'manager';
    /**
     * Whether the user account is active
     */
    isActive: boolean;
    /**
     * Last login timestamp
     */
    lastLoginAt?: string;
    /**
     * URL to user's profile image
     */
    profileImageUrl?: string;
    /**
     * User's phone number
     */
    phoneNumber?: string;
    /**
     * User's date of birth
     */
    dateOfBirth?: string;
    /**
     * How the user signed up
     */
    signupSource: 'direct' | 'team_invite' | 'invite_code';
    /**
     * Team ID if user joined through invite
     */
    joinedTeamId?: string;
    /**
     * 4-digit invite code used during signup
     */
    inviteCode?: string;
    /**
     * Cognito user ID for linking
     */
    cognitoUserId?: string;
    /**
     * Whether email is verified
     */
    emailVerified?: boolean;
    /**
     * User preferences and settings
     */
    preferences?: {
        notifications?: boolean;
        newsletter?: boolean;
        theme?: 'light' | 'dark' | 'auto';
    };
};

export type UserDbItem = GlobalDbItem & User & {
    entityType?: 'USER';
};

export type CreateUserRequest = {
    username: string;
    email: string;
    firstName: string;
    lastName: string;
    role?: 'player' | 'manager';
    phoneNumber?: string;
    dateOfBirth?: string;
    profileImageUrl?: string;
    /**
     * 4-digit team invite code for automatic team joining
     */
    inviteCode?: string;
    /**
     * Cognito user ID for system-created profiles
     */
    cognitoUserId?: string;
    signupSource?: 'direct' | 'team_invite' | 'invite_code';
    preferences?: {
        notifications?: boolean;
        newsletter?: boolean;
        theme?: 'light' | 'dark' | 'auto';
    };
};

export type SignUpWithInviteRequest = {
    /**
     * 4-digit team invite code
     */
    inviteCode: string;
    firstName: string;
    lastName: string;
    phoneNumber?: string;
    dateOfBirth?: string;
    preferences?: {
        notifications?: boolean;
        newsletter?: boolean;
    };
};

export type UpdateUserRequest = {
    email?: string;
    firstName?: string;
    lastName?: string;
    role?: 'player' | 'manager';
    isActive?: boolean;
    profileImageUrl?: string;
    phoneNumber?: string;
    dateOfBirth?: string;
    joinedTeamId?: string;
    signupSource?: 'direct' | 'team_invite' | 'invite_code';
    inviteCode?: string;
    preferences?: {
        notifications?: boolean;
        newsletter?: boolean;
        theme?: 'light' | 'dark' | 'auto';
    };
};

export type UserResponse = {
    message?: string;
    data?: User;
};

export type UserListResponse = {
    message?: string;
    data?: {
        result?: Array<User>;
        /**
         * Pagination token
         */
        nextToken?: string;
        /**
         * Whether more results exist
         */
        hasMore?: boolean;
        pagination?: {
            limit?: number;
            hasMore?: boolean;
        };
    };
};

export type Team = UserScopedEntity & {
    /**
     * Team name
     */
    name: string;
    /**
     * Team description
     */
    description?: string;
    /**
     * Sport the team plays
     */
    sport: string;
    /**
     * Team status
     */
    status?: 'active' | 'inactive' | 'archived';
    /**
     * Team members
     */
    members?: Array<{
        /**
         * User ID of team member
         */
        userId: string;
        /**
         * Member ID for API operations (update/delete)
         */
        memberId?: string;
        /**
         * Username of team member
         */
        username?: string;
        /**
         * Member's first name
         */
        firstName?: string;
        /**
         * Member's last name
         */
        lastName?: string;
        /**
         * Role in the team
         */
        role: 'captain' | 'player' | 'coach' | 'manager';
        /**
         * When the member joined the team
         */
        joinedAt?: string;
    }>;
    /**
     * Team settings
     */
    settings?: {
        /**
         * Whether the team is publicly visible
         */
        isPublic?: boolean;
        /**
         * Whether users can request to join
         */
        allowJoinRequests?: boolean;
        /**
         * Maximum number of team members
         */
        maxMembers?: number;
        /**
         * Unique 4-digit invite code for team joining
         */
        inviteCode?: string;
        /**
         * Whether invite code functionality is enabled
         */
        inviteCodeEnabled?: boolean;
    };
    /**
     * Team statistics
     */
    stats?: {
        /**
         * Number of wins
         */
        wins?: number;
        /**
         * Number of losses
         */
        losses?: number;
        /**
         * Number of draws
         */
        draws?: number;
        /**
         * Total games played
         */
        gamesPlayed?: number;
    };
};

export type TeamDbItem = DynamoDbItem & Team & {
    PK?: unknown;
    SK?: unknown;
    GSI2PK: unknown;
    GSI2SK: unknown;
    entityType?: 'TEAM';
};

export type CreateTeamRequest = {
    name: string;
    description?: string;
    sport?: string;
    status?: 'active' | 'inactive' | 'archived';
    members?: Array<{
        userId: string;
        username?: string;
        firstName?: string;
        lastName?: string;
        role: 'captain' | 'player' | 'coach' | 'manager';
    }>;
    settings?: {
        isPublic?: boolean;
        allowJoinRequests?: boolean;
        maxMembers?: number;
    };
};

export type UpdateTeamRequest = {
    name?: string;
    description?: string;
    sport?: string;
    status?: 'active' | 'inactive' | 'archived';
    members?: Array<{
        userId: string;
        username?: string;
        firstName?: string;
        lastName?: string;
        role: 'captain' | 'player' | 'coach' | 'manager';
    }>;
    settings?: {
        isPublic?: boolean;
        allowJoinRequests?: boolean;
        maxMembers?: number;
        /**
         * Unique 4-digit invite code for team joining
         */
        inviteCode?: string;
        /**
         * Whether invite code functionality is enabled
         */
        inviteCodeEnabled?: boolean;
    };
    stats?: {
        wins?: number;
        losses?: number;
        draws?: number;
        gamesPlayed?: number;
    };
};

export type TeamResponse = {
    message?: string;
    data?: Team;
};

export type TeamListResponse = {
    message?: string;
    data?: {
        result?: Array<Team>;
        /**
         * Pagination token
         */
        nextToken?: string;
        /**
         * Whether more results exist
         */
        hasMore?: boolean;
        pagination?: {
            limit?: number;
            hasMore?: boolean;
        };
    };
};

export type Member = BaseEntity & {
    /**
     * ID of the team this member belongs to
     */
    teamId: string;
    /**
     * Username of the member
     */
    username: string;
    /**
     * Member's first name
     */
    firstName?: string;
    /**
     * Member's last name
     */
    lastName?: string;
    /**
     * Role of the member in the team
     */
    role: 'player' | 'captain' | 'coach' | 'manager' | 'assistant_coach';
    /**
     * Status of the member
     */
    status: 'active' | 'inactive' | 'pending' | 'invited' | 'suspended';
    /**
     * When the member joined the team
     */
    joinedAt?: string;
    /**
     * When the member was invited to the team
     */
    invitedAt?: string;
    /**
     * Username of who invited this member
     */
    invitedBy?: string;
    /**
     * Member permissions
     */
    permissions?: {
        /**
         * Can invite new members
         */
        canInviteMembers?: boolean;
        /**
         * Can remove members
         */
        canRemoveMembers?: boolean;
        /**
         * Can edit team details
         */
        canEditTeam?: boolean;
        /**
         * Can manage team games/matches
         */
        canManageGames?: boolean;
    };
    /**
     * Additional member data
     */
    memberData?: {
        /**
         * Player position (e.g., forward, goalkeeper)
         */
        position?: string;
        /**
         * Jersey number
         */
        jerseyNumber?: number;
        /**
         * Emergency contact information
         */
        emergencyContact?: {
            name?: string;
            phone?: string;
            relationship?: string;
        };
        /**
         * Additional notes about the member
         */
        notes?: string;
    };
};

export type MemberDbItem = DynamoDbItem & Member & {
    PK?: unknown;
    SK?: unknown;
    GSI2PK: unknown;
    GSI2SK: unknown;
    entityType?: 'MEMBER';
};

export type CreateMemberRequest = {
    teamId: string;
    username: string;
    /**
     * Member's first name
     */
    firstName?: string;
    /**
     * Member's last name
     */
    lastName?: string;
    role: 'player' | 'captain' | 'coach' | 'manager' | 'assistant_coach';
    status?: 'active' | 'inactive' | 'pending' | 'invited' | 'suspended';
    permissions?: {
        canInviteMembers?: boolean;
        canRemoveMembers?: boolean;
        canEditTeam?: boolean;
        canManageGames?: boolean;
    };
    memberData?: {
        position?: string;
        jerseyNumber?: number;
        emergencyContact?: {
            name?: string;
            phone?: string;
            relationship?: string;
        };
        notes?: string;
    };
};

export type UpdateMemberRequest = {
    role?: 'player' | 'captain' | 'coach' | 'manager' | 'assistant_coach';
    status?: 'active' | 'inactive' | 'pending' | 'invited' | 'suspended';
    permissions?: {
        canInviteMembers?: boolean;
        canRemoveMembers?: boolean;
        canEditTeam?: boolean;
        canManageGames?: boolean;
    };
    memberData?: {
        position?: string;
        jerseyNumber?: number;
        emergencyContact?: {
            name?: string;
            phone?: string;
            relationship?: string;
        };
        notes?: string;
    };
};

export type MemberResponse = {
    message?: string;
    data?: Member;
};

export type MemberListResponse = {
    message?: string;
    data?: {
        result?: Array<Member>;
        /**
         * Pagination token
         */
        nextToken?: string;
        /**
         * Whether more results exist
         */
        hasMore?: boolean;
        pagination?: {
            limit?: number;
            hasMore?: boolean;
        };
    };
};

export type Game = BaseEntity & {
    /**
     * ID of the team this game belongs to (null for public games)
     */
    teamId?: string | null;
    /**
     * Name of the opponent team
     */
    opponentTeam: string;
    /**
     * ID of opponent team if it exists in the system
     */
    opponentTeamId?: string;
    /**
     * Type of game
     */
    gameType: 'league' | 'friendly' | 'tournament' | 'cup' | 'playoff';
    /**
     * Current status of the game
     */
    status: 'scheduled' | 'in_progress' | 'completed' | 'cancelled' | 'postponed';
    /**
     * Scheduled date and time of the game
     */
    scheduledDate: string;
    /**
     * Actual start time of the game
     */
    actualStartTime?: string;
    /**
     * Actual end time of the game
     */
    actualEndTime?: string;
    /**
     * Game venue information
     */
    venue?: {
        /**
         * Name of the venue
         */
        name?: string;
        /**
         * Address of the venue
         */
        address?: string;
        /**
         * Whether this is a home game
         */
        isHome?: boolean;
    };
    /**
     * Game score
     */
    score?: {
        /**
         * Home team score
         */
        home?: number;
        /**
         * Away team score
         */
        away?: number;
        /**
         * Whether our team is the home team
         */
        isHomeTeam?: boolean;
    };
    /**
     * Additional game data and statistics
     */
    gameData?: {
        /**
         * Game duration in minutes
         */
        duration?: number;
        /**
         * Referee name
         */
        referee?: string;
        /**
         * Weather conditions
         */
        weather?: string;
        /**
         * Number of attendees
         */
        attendance?: number;
        /**
         * Additional game notes
         */
        notes?: string;
        /**
         * Game highlights and events
         */
        highlights?: Array<{
            minute?: number;
            event?: 'goal' | 'yellow_card' | 'red_card' | 'substitution' | 'injury' | 'other';
            player?: string;
            description?: string;
        }>;
    };
    /**
     * Whether this game is publicly accessible without authentication
     */
    isPublic?: boolean;
};

export type GameDbItem = DynamoDbItem & Game & {
    /**
     * Team ID for team games, or PublicGame for public games
     */
    PK?: unknown;
    SK?: unknown;
    /**
     * Game ID for team games, or PublicGame for public games
     */
    GSI2PK: unknown;
    GSI2SK: unknown;
    entityType?: 'GAME';
};

export type CreateGameRequest = {
    name?: string;
    teamId?: string;
    opponentTeam: string;
    opponentTeamId?: string;
    gameType?: 'league' | 'friendly' | 'tournament' | 'cup' | 'playoff';
    status?: 'scheduled' | 'in_progress' | 'completed' | 'cancelled' | 'postponed';
    scheduledDate?: string;
    venue?: {
        name?: string;
        address?: string;
        isHome?: boolean;
    };
    gameData?: {
        referee?: string;
        weather?: string;
        notes?: string;
    };
    /**
     * Whether this game should be publicly accessible without authentication
     */
    isPublic?: boolean;
};

export type UpdateGameRequest = {
    opponentTeam?: string;
    opponentTeamId?: string;
    gameType?: 'league' | 'friendly' | 'tournament' | 'cup' | 'playoff';
    status?: 'scheduled' | 'in_progress' | 'completed' | 'cancelled' | 'postponed';
    scheduledDate?: string;
    actualStartTime?: string;
    actualEndTime?: string;
    venue?: {
        name?: string;
        address?: string;
        isHome?: boolean;
    };
    score?: {
        home?: number;
        away?: number;
        isHomeTeam?: boolean;
    };
    gameData?: {
        duration?: number;
        referee?: string;
        weather?: string;
        attendance?: number;
        notes?: string;
        highlights?: Array<{
            minute?: number;
            event?: 'goal' | 'yellow_card' | 'red_card' | 'substitution' | 'injury' | 'other';
            player?: string;
            description?: string;
        }>;
    };
    /**
     * Whether this game should be publicly accessible without authentication
     */
    isPublic?: boolean;
};

export type GameResponse = {
    message?: string;
    data?: Game;
};

export type GameListResponse = {
    message?: string;
    data?: {
        result?: Array<Game>;
        /**
         * Pagination token
         */
        nextToken?: string;
        /**
         * Whether more results exist
         */
        hasMore?: boolean;
        pagination?: {
            limit?: number;
            hasMore?: boolean;
        };
    };
};

export type Video = BaseEntity & {
    /**
     * ID of the game this video belongs to
     */
    gameId: string;
    /**
     * Title or name of the video
     */
    title: string;
    /**
     * Description of the video content
     */
    description?: string;
    /**
     * S3 object key where the video file is stored
     */
    s3Key: string;
    /**
     * URL to access the video file
     */
    s3Url: string;
    /**
     * Type of video content
     */
    videoType: 'highlight' | 'full_game' | 'training' | 'interview' | 'analysis' | 'other';
    /**
     * Current status of the video
     */
    status: 'processing' | 'processed' | 'ready' | 'failed' | 'archived';
    /**
     * Video duration in seconds
     */
    duration?: number;
    /**
     * Video file size in bytes
     */
    fileSize?: number;
    /**
     * Technical metadata about the video
     */
    videoMetadata?: {
        /**
         * Video resolution (e.g., 1920x1080)
         */
        resolution?: string;
        /**
         * Video framerate (fps)
         */
        framerate?: number;
        /**
         * Video codec used
         */
        codec?: string;
        /**
         * Video bitrate in kbps
         */
        bitrate?: number;
        /**
         * Video file format (e.g., mp4, avi)
         */
        format?: string;
    };
    /**
     * S3 key for video thumbnail image
     */
    thumbnailS3Key?: string;
    /**
     * URL for video thumbnail image
     */
    thumbnailS3Url?: string;
    /**
     * Username of who uploaded the video
     */
    uploadedBy?: string;
    /**
     * Tags for categorizing the video
     */
    tags?: Array<string>;
    /**
     * AWS MediaConvert job ID for video processing
     */
    mediaConvertJobId?: string;
    /**
     * URL to HLS playlist for adaptive streaming
     */
    hlsPlaylistUrl?: string;
    /**
     * URL to optimized MP4 for progressive download
     */
    mp4StreamUrl?: string;
    /**
     * S3 key prefix for processed video outputs
     */
    processedS3KeyPrefix?: string;
    matchTimeMarkers?: MatchTimeMarkers;
    /**
     * AWS MediaConvert job ID for trimmed video processing
     */
    trimmedMediaConvertJobId?: string;
    /**
     * AWS MediaConvert job ID for clips processing
     */
    clipsMediaConvertJobId?: string;
    /**
     * Status of trimmed video processing
     */
    trimmedProcessingStatus?: 'pending' | 'processing' | 'completed' | 'failed';
    /**
     * Status of clips processing
     */
    clipsProcessingStatus?: 'pending' | 'processing' | 'completed' | 'failed';
    /**
     * URL to trimmed video HLS playlist
     */
    trimmedHlsPlaylistUrl?: string;
    /**
     * URL to trimmed video MP4 stream
     */
    trimmedMp4StreamUrl?: string;
    /**
     * S3 key for trimmed video file
     */
    trimmedS3Key?: string;
    /**
     * URL to trimmed video file
     */
    trimmedS3Url?: string;
    trimmedMatchTimeMarkers?: MatchTimeMarkers;
    /**
     * S3 key prefix for video clips
     */
    clipsS3KeyPrefix?: string;
    /**
     * Number of clips generated for first half
     */
    firstHalfClipsCount?: number;
    /**
     * Number of clips generated for second half
     */
    secondHalfClipsCount?: number;
    /**
     * Whether this video is publicly accessible without authentication
     */
    isPublic?: boolean;
};

export type VideoDbItem = DynamoDbItem & Video & {
    /**
     * Game ID for team games, or PublicGame for public games
     */
    PK?: unknown;
    SK?: unknown;
    /**
     * Video ID for team videos, or PublicVideo for public videos
     */
    GSI2PK: unknown;
    GSI2SK: unknown;
    entityType?: 'VIDEO';
};

export type CreateVideoRequest = {
    gameId: string;
    title?: string;
    description?: string;
    /**
     * S3 key for the video file. Either s3Key or videoUrl must be provided.
     */
    s3Key?: string;
    /**
     * URL to download the video from. The video will be downloaded and uploaded to S3. Either s3Key or videoUrl must be provided.
     */
    videoUrl?: string;
    /**
     * Optional - will be computed from CloudFront URL and s3Key if not provided
     */
    s3Url?: string;
    videoType?: 'highlight' | 'full_game' | 'training' | 'interview' | 'analysis' | 'other';
    status?: 'processing' | 'ready' | 'failed' | 'archived';
    duration?: number;
    fileSize?: number;
    videoMetadata?: {
        resolution?: string;
        framerate?: number;
        codec?: string;
        bitrate?: number;
        format?: string;
    };
    thumbnailS3Key?: string;
    /**
     * Optional - will be computed from CloudFront URL and thumbnailS3Key if not provided
     */
    thumbnailS3Url?: string;
    tags?: Array<string>;
    /**
     * Whether this video should be publicly accessible without authentication
     */
    isPublic?: boolean;
};

/**
 * Request to upload a video from a URL asynchronously
 */
export type UploadVideoFromUrlRequest = {
    /**
     * ID of the game to associate the video with
     */
    gameId: string;
    /**
     * URL of the video to download and upload to S3
     */
    videoUrl: string;
};

export type UpdateVideoRequest = {
    title?: string;
    description?: string;
    videoType?: 'highlight' | 'full_game' | 'training' | 'interview' | 'analysis' | 'other';
    status?: 'processing' | 'ready' | 'failed' | 'archived';
    duration?: number;
    fileSize?: number;
    videoMetadata?: {
        resolution?: string;
        framerate?: number;
        codec?: string;
        bitrate?: number;
        format?: string;
    };
    thumbnailS3Key?: string;
    thumbnailS3Url?: string;
    tags?: Array<string>;
    /**
     * Whether this video should be publicly accessible without authentication
     */
    isPublic?: boolean;
    /**
     * AWS MediaConvert job ID for video processing
     */
    mediaConvertJobId?: string;
    /**
     * URL to HLS playlist for adaptive streaming
     */
    hlsPlaylistUrl?: string;
    /**
     * URL to optimized MP4 for progressive download
     */
    mp4StreamUrl?: string;
    /**
     * S3 key prefix for processed video outputs
     */
    processedS3KeyPrefix?: string;
    matchTimeMarkers?: MatchTimeMarkers;
    /**
     * AWS MediaConvert job ID for trimmed video processing
     */
    trimmedMediaConvertJobId?: string;
    /**
     * AWS MediaConvert job ID for clips processing
     */
    clipsMediaConvertJobId?: string;
    /**
     * Status of trimmed video processing
     */
    trimmedProcessingStatus?: 'pending' | 'processing' | 'completed' | 'failed';
    /**
     * Status of clips processing
     */
    clipsProcessingStatus?: 'pending' | 'processing' | 'completed' | 'failed';
    /**
     * URL to trimmed video HLS playlist
     */
    trimmedHlsPlaylistUrl?: string;
    /**
     * URL to trimmed video MP4 stream
     */
    trimmedMp4StreamUrl?: string;
    /**
     * S3 key for trimmed video file
     */
    trimmedS3Key?: string;
    /**
     * URL to trimmed video file
     */
    trimmedS3Url?: string;
    trimmedMatchTimeMarkers?: MatchTimeMarkers;
    /**
     * S3 key prefix for video clips
     */
    clipsS3KeyPrefix?: string;
    /**
     * Number of clips generated for first half
     */
    firstHalfClipsCount?: number;
    /**
     * Number of clips generated for second half
     */
    secondHalfClipsCount?: number;
};

export type VideoResponse = {
    message?: string;
    data?: Video;
};

export type VideoListResponse = {
    message?: string;
    data?: {
        result?: Array<Video>;
        /**
         * Pagination token
         */
        nextToken?: string;
        /**
         * Whether more results exist
         */
        hasMore?: boolean;
        pagination?: {
            limit?: number;
            hasMore?: boolean;
        };
    };
};

export type VideoUploadUrlResponse = {
    /**
     * Pre-signed S3 URL for uploading the video file
     */
    url?: string;
    /**
     * S3 object key where the file will be stored
     */
    key?: string;
};

export type Analysis = BaseEntity & {
    /**
     * ID of the video this analysis belongs to
     */
    videoId: string;
    /**
     * Type of AI analysis performed
     */
    analysisType: 'performance' | 'tactical' | 'technical' | 'emotional' | 'highlight_detection' | 'player_tracking' | 'event_detection' | 'statistics' | 'custom';
    /**
     * Current status of the analysis
     */
    status: 'queued' | 'processing' | 'completed' | 'failed' | 'cancelled';
    /**
     * Name of the AI model used for analysis
     */
    modelName: string;
    /**
     * Version of the AI model used
     */
    modelVersion: string;
    /**
     * Overall confidence score of the analysis (0-1)
     */
    confidence?: number;
    /**
     * Time taken to process the analysis in milliseconds
     */
    processingTimeMs?: number;
    /**
     * The actual analysis results (flexible JSON structure)
     */
    analysisData?: {
        [key: string]: unknown;
    };
    /**
     * Additional metadata about the analysis
     */
    metadata?: {
        /**
         * Parameters used for the analysis
         */
        inputParameters?: {
            [key: string]: unknown;
        };
        /**
         * Video segments relevant to this analysis
         */
        videoSegments?: Array<{
            /**
             * Start time in seconds
             */
            startTime?: number;
            /**
             * End time in seconds
             */
            endTime?: number;
            description?: string;
            confidence?: number;
        }>;
        /**
         * Analysis-specific tags
         */
        tags?: Array<string>;
    };
    /**
     * Error details if analysis failed
     */
    errorDetails?: {
        errorCode?: string;
        errorMessage?: string;
        stackTrace?: string;
    };
    /**
     * Username of who initiated the analysis
     */
    initiatedBy?: string;
    /**
     * Timestamp when analysis was completed
     */
    completedAt?: string;
};

export type AnalysisDbItem = DynamoDbItem & Analysis & {
    PK?: unknown;
    SK?: unknown;
    GSI2PK: unknown;
    GSI2SK: unknown;
    entityType?: 'ANALYSIS';
};

export type CreateAnalysisRequest = {
    videoId: string;
    analysisType: 'performance' | 'tactical' | 'technical' | 'emotional' | 'highlight_detection' | 'player_tracking' | 'event_detection' | 'statistics' | 'custom';
    modelName: string;
    modelVersion: string;
    status?: 'queued' | 'processing' | 'completed' | 'failed' | 'cancelled';
    metadata?: {
        inputParameters?: {
            [key: string]: unknown;
        };
        tags?: Array<string>;
    };
};

export type UpdateAnalysisRequest = {
    status?: 'queued' | 'processing' | 'completed' | 'failed' | 'cancelled';
    confidence?: number;
    processingTimeMs?: number;
    analysisData?: {
        [key: string]: unknown;
    };
    metadata?: {
        inputParameters?: {
            [key: string]: unknown;
        };
        videoSegments?: Array<{
            startTime?: number;
            endTime?: number;
            description?: string;
            confidence?: number;
        }>;
        tags?: Array<string>;
    };
    errorDetails?: {
        errorCode?: string;
        errorMessage?: string;
        stackTrace?: string;
    };
    completedAt?: string;
};

export type AnalysisResponse = {
    message?: string;
    data?: Analysis;
};

export type AnalysisListResponse = {
    message?: string;
    data?: {
        result?: Array<Analysis>;
        /**
         * Pagination token
         */
        nextToken?: string;
        /**
         * Whether more results exist
         */
        hasMore?: boolean;
        pagination?: {
            limit?: number;
            hasMore?: boolean;
        };
    };
};

/**
 * Time markers for match periods to focus analysis on actual match play
 */
export type MatchTimeMarkers = {
    /**
     * Start of first half (throw-in) in seconds
     */
    firstHalfStart: number;
    /**
     * Half time whistle in seconds
     */
    halfTime: number;
    /**
     * Start of second half (throw-in) in seconds
     */
    secondHalfStart: number;
    /**
     * Full time whistle (end of match) in seconds
     */
    fullTime: number;
};

/**
 * Type of prompt to use for video analysis
 */
export type PromptType = 'GAA_EVENT_ANALYSIS';

/**
 * GAA Event Analysis output from Gemini API
 */
export type AiEventOutput = {
    events: Array<Event>;
    matchMetadata: {
        /**
         * Duration of the analyzed segment in seconds
         */
        totalDuration: number;
        teamsDetected: {
            teamA?: 'teamA';
            teamB?: 'teamB';
        };
        /**
         * Overall confidence of the analysis
         */
        confidence: number;
        /**
         * Time when halftime was detected (optional)
         */
        halftimeDetected?: number;
        videoQuality: 'low' | 'medium' | 'high' | 'unknown';
    };
};

/**
 * Individual GAA event detected in video
 */
export type Event = {
    /**
     * Time of event in seconds from segment start
     */
    time: number;
    team: 'Team A' | 'Team B';
    action: ActionType;
    outcome: OutcomeType;
    cardType?: CardType;
    confidence: number;
    /**
     * Whether the event has been validated
     */
    validated: boolean;
};

/**
 * Type of GAA action
 */
export type ActionType = 'Throw-up' | 'Turnover' | 'Kickout' | 'Kick-in' | 'Shot' | 'Foul';

/**
 * Type of card shown (for fouls)
 */
export type CardType = 'Yellow Card' | 'Black Card' | 'Red Card';

/**
 * Outcome of the action
 */
export type OutcomeType = 'Won' | 'Lost' | 'N/A' | '1Point' | '2Point' | 'Goal' | 'Wide' | 'Saved' | 'Awarded To';

/**
 * Analysis result for a single video segment
 */
export type VideoSegmentAnalysis = {
    id: string;
    videoId: string;
    gameId: string;
    teamId: string;
    promptType: PromptType;
    /**
     * Index of the segment (0-based)
     */
    segmentIndex: number;
    /**
     * Start time of segment in seconds
     */
    startTime: number;
    /**
     * End time of segment in seconds
     */
    endTime: number;
    geminiResponse: AiEventOutput;
    matchTimeMarkers?: MatchTimeMarkers;
    /**
     * Time taken to process this segment in milliseconds
     */
    processingTime: number;
    /**
     * Gemini model used for analysis
     */
    model: string;
    /**
     * Username who initiated the analysis
     */
    createdBy: string;
    createdAt: string;
    updatedAt: string;
};

/**
 * Combined analysis that merges all segments into one analysis with corrected timing
 */
export type CombinedVideoAnalysis = {
    id: string;
    videoId: string;
    gameId: string;
    teamId: string;
    /**
     * Links to the VideoAnalysisResponse that generated this
     */
    analysisId: string;
    promptType: PromptType;
    combinedAnalysis: AiEventOutput;
    /**
     * Metadata about the segments that were combined
     */
    sourceSegments: Array<{
        segmentIndex: number;
        startTime: number;
        endTime: number;
        eventsCount: number;
        confidence: number;
    }>;
    /**
     * Total number of events in the combined analysis
     */
    totalEvents: number;
    /**
     * Total duration of all analyzed segments in seconds
     */
    totalDuration: number;
    /**
     * Average confidence across all segments
     */
    averageConfidence: number;
    matchTimeMarkers: MatchTimeMarkers;
    /**
     * Gemini model used for analysis
     */
    geminiModel: string;
    /**
     * Total time taken to process all segments in milliseconds
     */
    totalProcessingTime: number;
    /**
     * Username who initiated the analysis
     */
    createdBy: string;
    createdAt: string;
    updatedAt: string;
};

/**
 * Response for video analysis request
 */
export type VideoAnalysisResponse = {
    message?: string;
    data?: {
        /**
         * Unique identifier for this analysis run
         */
        analysisId: string;
        gameId: string;
        videoId: string;
        teamId: string;
        status: 'processing' | 'completed' | 'failed';
        segments: Array<{
            segmentIndex?: number;
            startTime?: number;
            endTime?: number;
            promptType?: PromptType;
            geminiResponse?: AiEventOutput;
            processingTime?: number;
            timestamp?: string;
        }>;
        totalSegments: number;
        completedSegments: number;
        createdAt: string;
        updatedAt: string;
        processingTimeMs: number;
    };
};

/**
 * Response for retrieving video analyses - includes both segment and combined analyses
 */
export type VideoAnalysisListResponse = {
    message?: string;
    data?: {
        gameId: string;
        videoId: string;
        /**
         * Granular analysis per video segment
         */
        segmentAnalyses: Array<VideoSegmentAnalysis>;
        /**
         * Full video analysis with corrected timing
         */
        combinedAnalyses: Array<CombinedVideoAnalysis>;
        pagination: {
            nextToken?: string;
            hasMore?: boolean;
            limit?: number;
        };
        summary: {
            /**
             * Number of segment analyses
             */
            totalSegmentAnalyses: number;
            /**
             * Total events across all segment analyses
             */
            totalSegmentEvents: number;
            /**
             * Number of combined analyses
             */
            totalCombinedAnalyses: number;
            /**
             * Total events across all combined analyses
             */
            totalCombinedEvents: number;
            /**
             * All prompt types found in analyses
             */
            promptTypes: Array<PromptType>;
            /**
             * List of segment indices (sorted)
             */
            segments: Array<number>;
            breakdown: {
                segmentAnalyses: {
                    count: number;
                    events: number;
                    description: string;
                };
                combinedAnalyses: {
                    count: number;
                    events: number;
                    description: string;
                };
            };
        };
    };
};

/**
 * Response when creating an async task
 */
export type AsyncTaskResponse = {
    message: string;
    /**
     * Unique identifier for the async task
     */
    taskId: string;
    /**
     * Initial task status
     */
    status: 'processing';
    /**
     * Game ID from the request
     */
    gameId: string;
    /**
     * Video ID from the request
     */
    videoId: string;
    /**
     * Team ID from the request
     */
    teamId: string;
    /**
     * URL to poll for task completion
     */
    pollUrl: string;
    /**
     * Estimated time for task completion
     */
    estimatedCompletionTime: string;
};

export type TaskBase = {
    /**
     * Task partition key (same as taskId)
     */
    PK: string;
    /**
     * Task sort key
     */
    SK: string;
    /**
     * Unique task identifier
     */
    taskId: string;
    /**
     * Current task status
     */
    status: 'processing' | 'completed' | 'failed';
    /**
     * Task creation timestamp
     */
    timestamp: string;
};

export type TaskProcessing = TaskBase & {
    status?: 'processing';
};

export type TaskCompleted = TaskBase & {
    status?: 'completed';
    result: VideoAnalysisResult | VideoUploadResult;
};

export type TaskFailed = TaskBase & {
    status?: 'failed';
    result: string | {
        /**
         * Error message
         */
        error?: string;
        /**
         * Additional error details
         */
        details?: {
            [key: string]: unknown;
        };
    };
};

/**
 * Complete video analysis results from async task
 */
export type VideoAnalysisResult = {
    /**
     * Unique identifier for this analysis run
     */
    analysisId: string;
    gameId: string;
    videoId: string;
    teamId: string;
    status: 'completed' | 'failed';
    segments: Array<{
        segmentIndex?: number;
        startTime?: number;
        endTime?: number;
        promptType?: PromptType;
        geminiResponse?: AiEventOutput;
        /**
         * Raw response from Gemini API for debugging
         */
        rawGeminiResponse?: unknown;
        /**
         * Processing time in milliseconds
         */
        processingTime?: number;
        timestamp?: string;
    }>;
    totalSegments: number;
    completedSegments: number;
    createdAt: string;
    updatedAt: string;
    processingTimeMs: number;
};

/**
 * Result of video upload from URL async task
 */
export type VideoUploadResult = {
    /**
     * ID of the created video record
     */
    videoId: string;
    /**
     * S3 key where the video was uploaded
     */
    s3Key: string;
    /**
     * Size of the uploaded video file in bytes
     */
    fileSize: number;
    /**
     * MIME type of the uploaded video
     */
    contentType: string;
    /**
     * Original URL that the video was downloaded from
     */
    originalUrl: string;
};

export type SuccessResponse = {
    /**
     * Success message
     */
    message?: string;
    /**
     * Response data
     */
    data?: {
        [key: string]: unknown;
    } | Array<unknown> | string | number | boolean;
};

export type PaginatedResponse = {
    /**
     * Success message
     */
    message?: string;
    data?: {
        /**
         * Array of items
         */
        items?: Array<unknown>;
        /**
         * Token for next page
         */
        nextToken?: string;
        /**
         * Whether there are more items
         */
        hasMore?: boolean;
        pagination?: {
            /**
             * Items per page
             */
            limit?: number;
            /**
             * Whether there are more items
             */
            hasMore?: boolean;
        };
    };
};

export type _Error = {
    /**
     * Error message
     */
    message: string;
    /**
     * Detailed error information
     */
    details?: Array<{
        field?: string;
        message?: string;
        code?: string;
    }>;
};

export type ValidationError = _Error & {
    details?: Array<{
        instancePath?: string;
        schemaPath?: string;
        keyword?: string;
        params?: {
            [key: string]: unknown;
        };
        message?: string;
    }>;
};

export type TeamWithMembership = Team & {
    userMembership?: {
        /**
         * User's role in the team
         */
        role?: string;
        /**
         * User's membership status
         */
        status?: string;
        /**
         * When the user joined the team
         */
        joinedAt?: string;
        /**
         * When the user was invited to the team
         */
        invitedAt?: string;
    };
};

/**
 * Entity ID
 */
export type IdPathParam = string;

/**
 * Number of items to return (1-100)
 */
export type LimitQueryParam = number;

/**
 * Token for pagination
 */
export type NextTokenQueryParam = string;

/**
 * Sort order for results
 */
export type SortOrderQueryParam = 'asc' | 'desc';

export type HealthCheckData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/health';
};

export type HealthCheckResponses = {
    /**
     * Service is healthy
     */
    200: {
        status?: string;
        timestamp?: string;
        service?: string;
    };
};

export type HealthCheckResponse = HealthCheckResponses[keyof HealthCheckResponses];

export type ListUsersData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Number of items to return (1-100)
         */
        limit?: number;
        /**
         * Token for pagination
         */
        nextToken?: string;
        /**
         * Sort order for results
         */
        sortOrder?: 'asc' | 'desc';
        /**
         * Filter by user role
         */
        role?: 'player' | 'manager';
        /**
         * Filter by active status
         */
        isActive?: boolean;
        /**
         * Search by username, email, or name
         */
        search?: string;
    };
    url: '/users';
};

export type ListUsersErrors = {
    /**
     * Internal server error
     */
    500: _Error;
};

export type ListUsersError = ListUsersErrors[keyof ListUsersErrors];

export type ListUsersResponses = {
    /**
     * Users retrieved successfully
     */
    200: UserListResponse;
};

export type ListUsersResponse = ListUsersResponses[keyof ListUsersResponses];

export type CreateUserData = {
    body: CreateUserRequest;
    path?: never;
    query?: never;
    url: '/users';
};

export type CreateUserErrors = {
    /**
     * Bad request
     */
    400: ValidationError;
    /**
     * Internal server error
     */
    500: _Error;
};

export type CreateUserError = CreateUserErrors[keyof CreateUserErrors];

export type CreateUserResponses = {
    /**
     * User created successfully
     */
    201: UserResponse;
};

export type CreateUserResponse = CreateUserResponses[keyof CreateUserResponses];

export type SignupWithInviteData = {
    body: SignUpWithInviteRequest;
    path?: never;
    query?: never;
    url: '/users/signup-with-invite';
};

export type SignupWithInviteErrors = {
    /**
     * Bad request
     */
    400: ValidationError;
    /**
     * Invalid invite code
     */
    404: _Error;
    /**
     * Internal server error
     */
    500: _Error;
};

export type SignupWithInviteError = SignupWithInviteErrors[keyof SignupWithInviteErrors];

export type SignupWithInviteResponses = {
    /**
     * User profile completed and team joined
     */
    200: {
        message?: string;
        data?: {
            user?: User;
            team?: Team;
        };
    };
};

export type SignupWithInviteResponse = SignupWithInviteResponses[keyof SignupWithInviteResponses];

export type VerifyInviteCodeData = {
    body?: never;
    path: {
        /**
         * Team invite code
         */
        code: string;
    };
    query?: never;
    url: '/users/verify-invite-code/{code}';
};

export type VerifyInviteCodeErrors = {
    /**
     * Invalid or expired invite code
     */
    404: _Error;
    /**
     * Internal server error
     */
    500: _Error;
};

export type VerifyInviteCodeError = VerifyInviteCodeErrors[keyof VerifyInviteCodeErrors];

export type VerifyInviteCodeResponses = {
    /**
     * Invite code is valid
     */
    200: {
        message?: string;
        data?: {
            team?: {
                id?: string;
                name?: string;
                sport?: string;
                description?: string;
            };
        };
    };
};

export type VerifyInviteCodeResponse = VerifyInviteCodeResponses[keyof VerifyInviteCodeResponses];

export type JoinTeamData = {
    body: {
        /**
         * 4-digit team invite code
         */
        inviteCode: string;
    };
    path?: never;
    query?: never;
    url: '/users/join-team';
};

export type JoinTeamErrors = {
    /**
     * Bad request (e.g., already joined a team, already a member)
     */
    400: _Error;
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Invalid invite code or team not found
     */
    404: _Error;
    /**
     * Internal server error
     */
    500: _Error;
};

export type JoinTeamError = JoinTeamErrors[keyof JoinTeamErrors];

export type JoinTeamResponses = {
    /**
     * Successfully joined team
     */
    200: {
        message?: string;
        data?: {
            user?: User;
            team?: Team;
            member?: Member;
        };
    };
};

export type JoinTeamResponse = JoinTeamResponses[keyof JoinTeamResponses];

export type GetCurrentUserData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/users/me';
};

export type GetCurrentUserErrors = {
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Resource not found
     */
    404: _Error;
    /**
     * Internal server error
     */
    500: _Error;
};

export type GetCurrentUserError = GetCurrentUserErrors[keyof GetCurrentUserErrors];

export type GetCurrentUserResponses = {
    /**
     * User profile retrieved successfully
     */
    200: UserResponse;
};

export type GetCurrentUserResponse = GetCurrentUserResponses[keyof GetCurrentUserResponses];

export type DeleteUserData = {
    body?: never;
    path: {
        /**
         * Entity ID
         */
        id: string;
    };
    query?: never;
    url: '/users/{id}';
};

export type DeleteUserErrors = {
    /**
     * Resource not found
     */
    404: _Error;
    /**
     * Internal server error
     */
    500: _Error;
};

export type DeleteUserError = DeleteUserErrors[keyof DeleteUserErrors];

export type DeleteUserResponses = {
    /**
     * User deleted successfully
     */
    200: {
        message?: string;
    };
};

export type DeleteUserResponse = DeleteUserResponses[keyof DeleteUserResponses];

export type GetUserData = {
    body?: never;
    path: {
        /**
         * Entity ID
         */
        id: string;
    };
    query?: never;
    url: '/users/{id}';
};

export type GetUserErrors = {
    /**
     * Resource not found
     */
    404: _Error;
    /**
     * Internal server error
     */
    500: _Error;
};

export type GetUserError = GetUserErrors[keyof GetUserErrors];

export type GetUserResponses = {
    /**
     * User retrieved successfully
     */
    200: UserResponse;
};

export type GetUserResponse = GetUserResponses[keyof GetUserResponses];

export type UpdateUserData = {
    body: UpdateUserRequest;
    path: {
        /**
         * Entity ID
         */
        id: string;
    };
    query?: never;
    url: '/users/{id}';
};

export type UpdateUserErrors = {
    /**
     * Bad request
     */
    400: ValidationError;
    /**
     * Resource not found
     */
    404: _Error;
    /**
     * Internal server error
     */
    500: _Error;
};

export type UpdateUserError = UpdateUserErrors[keyof UpdateUserErrors];

export type UpdateUserResponses = {
    /**
     * User updated successfully
     */
    200: UserResponse;
};

export type UpdateUserResponse = UpdateUserResponses[keyof UpdateUserResponses];

export type ListTeamsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Number of items to return (1-100)
         */
        limit?: number;
        /**
         * Token for pagination
         */
        nextToken?: string;
        /**
         * Sort order for results
         */
        sortOrder?: 'asc' | 'desc';
        /**
         * Filter by team status
         */
        status?: 'active' | 'inactive' | 'archived';
        /**
         * Filter by sport
         */
        sport?: string;
    };
    url: '/teams';
};

export type ListTeamsErrors = {
    /**
     * Bad request
     */
    400: ValidationError;
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Internal server error
     */
    500: _Error;
};

export type ListTeamsError = ListTeamsErrors[keyof ListTeamsErrors];

export type ListTeamsResponses = {
    /**
     * Teams retrieved successfully
     */
    200: TeamListResponse;
};

export type ListTeamsResponse = ListTeamsResponses[keyof ListTeamsResponses];

export type CreateTeamData = {
    body: CreateTeamRequest;
    path?: never;
    query?: never;
    url: '/teams';
};

export type CreateTeamErrors = {
    /**
     * Bad request
     */
    400: ValidationError;
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Internal server error
     */
    500: _Error;
};

export type CreateTeamError = CreateTeamErrors[keyof CreateTeamErrors];

export type CreateTeamResponses = {
    /**
     * Team created successfully
     */
    201: TeamResponse;
};

export type CreateTeamResponse = CreateTeamResponses[keyof CreateTeamResponses];

export type GetTeamByInviteCodeData = {
    body?: never;
    path: {
        /**
         * 4-digit team invite code
         */
        code: string;
    };
    query?: never;
    url: '/teams/by-invite-code/{code}';
};

export type GetTeamByInviteCodeErrors = {
    /**
     * Resource not found
     */
    404: _Error;
    /**
     * Internal server error
     */
    500: _Error;
};

export type GetTeamByInviteCodeError = GetTeamByInviteCodeErrors[keyof GetTeamByInviteCodeErrors];

export type GetTeamByInviteCodeResponses = {
    /**
     * Team retrieved successfully
     */
    200: TeamResponse;
};

export type GetTeamByInviteCodeResponse = GetTeamByInviteCodeResponses[keyof GetTeamByInviteCodeResponses];

export type DeleteTeamData = {
    body?: never;
    path: {
        /**
         * Team ID
         */
        id: string;
    };
    query?: never;
    url: '/teams/{id}';
};

export type DeleteTeamErrors = {
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Forbidden
     */
    403: _Error;
    /**
     * Resource not found
     */
    404: _Error;
    /**
     * Internal server error
     */
    500: _Error;
};

export type DeleteTeamError = DeleteTeamErrors[keyof DeleteTeamErrors];

export type DeleteTeamResponses = {
    /**
     * Team deleted successfully
     */
    200: {
        message?: string;
    };
};

export type DeleteTeamResponse = DeleteTeamResponses[keyof DeleteTeamResponses];

export type GetTeamData = {
    body?: never;
    path: {
        /**
         * Team ID
         */
        id: string;
    };
    query?: never;
    url: '/teams/{id}';
};

export type GetTeamErrors = {
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Forbidden
     */
    403: _Error;
    /**
     * Resource not found
     */
    404: _Error;
    /**
     * Internal server error
     */
    500: _Error;
};

export type GetTeamError = GetTeamErrors[keyof GetTeamErrors];

export type GetTeamResponses = {
    /**
     * Team retrieved successfully
     */
    200: TeamResponse;
};

export type GetTeamResponse = GetTeamResponses[keyof GetTeamResponses];

export type UpdateTeamData = {
    body: UpdateTeamRequest;
    path: {
        /**
         * Team ID
         */
        id: string;
    };
    query?: never;
    url: '/teams/{id}';
};

export type UpdateTeamErrors = {
    /**
     * Bad request
     */
    400: ValidationError;
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Forbidden
     */
    403: _Error;
    /**
     * Resource not found
     */
    404: _Error;
    /**
     * Internal server error
     */
    500: _Error;
};

export type UpdateTeamError = UpdateTeamErrors[keyof UpdateTeamErrors];

export type UpdateTeamResponses = {
    /**
     * Team updated successfully
     */
    200: TeamResponse;
};

export type UpdateTeamResponse = UpdateTeamResponses[keyof UpdateTeamResponses];

export type ListMembersData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Number of items to return (1-100)
         */
        limit?: number;
        /**
         * Token for pagination
         */
        nextToken?: string;
        /**
         * Sort order for results
         */
        sortOrder?: 'asc' | 'desc';
        /**
         * Filter by team ID
         */
        teamId?: string;
        /**
         * Filter by member role
         */
        role?: 'player' | 'captain' | 'coach' | 'manager' | 'assistant_coach';
        /**
         * Filter by member status
         */
        status?: 'active' | 'inactive' | 'pending' | 'invited' | 'suspended';
        /**
         * Filter by user ID
         */
        userId?: string;
    };
    url: '/members';
};

export type ListMembersErrors = {
    /**
     * Bad request
     */
    400: ValidationError;
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Internal server error
     */
    500: _Error;
};

export type ListMembersError = ListMembersErrors[keyof ListMembersErrors];

export type ListMembersResponses = {
    /**
     * Members retrieved successfully
     */
    200: MemberListResponse;
};

export type ListMembersResponse = ListMembersResponses[keyof ListMembersResponses];

export type CreateMemberData = {
    body: CreateMemberRequest;
    path?: never;
    query?: never;
    url: '/members';
};

export type CreateMemberErrors = {
    /**
     * Bad request
     */
    400: ValidationError;
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Forbidden
     */
    403: _Error;
    /**
     * Internal server error
     */
    500: _Error;
};

export type CreateMemberError = CreateMemberErrors[keyof CreateMemberErrors];

export type CreateMemberResponses = {
    /**
     * Member added successfully
     */
    201: MemberResponse;
};

export type CreateMemberResponse = CreateMemberResponses[keyof CreateMemberResponses];

export type DeleteMemberData = {
    body?: never;
    path: {
        /**
         * Member ID
         */
        id: string;
    };
    query: {
        /**
         * Team ID for member lookup
         */
        teamId: string;
    };
    url: '/members/{id}';
};

export type DeleteMemberErrors = {
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Forbidden
     */
    403: _Error;
    /**
     * Resource not found
     */
    404: _Error;
    /**
     * Internal server error
     */
    500: _Error;
};

export type DeleteMemberError = DeleteMemberErrors[keyof DeleteMemberErrors];

export type DeleteMemberResponses = {
    /**
     * Member removed successfully
     */
    200: {
        message?: string;
    };
};

export type DeleteMemberResponse = DeleteMemberResponses[keyof DeleteMemberResponses];

export type GetMemberData = {
    body?: never;
    path: {
        /**
         * Member ID
         */
        id: string;
    };
    query?: never;
    url: '/members/{id}';
};

export type GetMemberErrors = {
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Forbidden
     */
    403: _Error;
    /**
     * Resource not found
     */
    404: _Error;
    /**
     * Internal server error
     */
    500: _Error;
};

export type GetMemberError = GetMemberErrors[keyof GetMemberErrors];

export type GetMemberResponses = {
    /**
     * Member retrieved successfully
     */
    200: MemberResponse;
};

export type GetMemberResponse = GetMemberResponses[keyof GetMemberResponses];

export type UpdateMemberData = {
    body: UpdateMemberRequest;
    path: {
        /**
         * Member ID
         */
        id: string;
    };
    query: {
        /**
         * Team ID for member lookup
         */
        teamId: string;
    };
    url: '/members/{id}';
};

export type UpdateMemberErrors = {
    /**
     * Bad request
     */
    400: ValidationError;
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Forbidden
     */
    403: _Error;
    /**
     * Resource not found
     */
    404: _Error;
    /**
     * Internal server error
     */
    500: _Error;
};

export type UpdateMemberError = UpdateMemberErrors[keyof UpdateMemberErrors];

export type UpdateMemberResponses = {
    /**
     * Member updated successfully
     */
    200: MemberResponse;
};

export type UpdateMemberResponse = UpdateMemberResponses[keyof UpdateMemberResponses];

export type ListGamesData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Number of items to return (1-100)
         */
        limit?: number;
        /**
         * Token for pagination
         */
        nextToken?: string;
        /**
         * Sort order for results
         */
        sortOrder?: 'asc' | 'desc';
        /**
         * Filter by team ID (required for team-scoped access)
         */
        teamId?: string;
        /**
         * Filter by game status
         */
        status?: 'scheduled' | 'in_progress' | 'completed' | 'cancelled' | 'postponed';
        /**
         * Filter by game type
         */
        gameType?: 'league' | 'friendly' | 'tournament' | 'cup' | 'playoff';
        /**
         * Filter games from this date
         */
        dateFrom?: string;
        /**
         * Filter games until this date
         */
        dateTo?: string;
    };
    url: '/games';
};

export type ListGamesErrors = {
    /**
     * Bad request
     */
    400: ValidationError;
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Forbidden
     */
    403: _Error;
    /**
     * Internal server error
     */
    500: _Error;
};

export type ListGamesError = ListGamesErrors[keyof ListGamesErrors];

export type ListGamesResponses = {
    /**
     * Games retrieved successfully
     */
    200: GameListResponse;
};

export type ListGamesResponse = ListGamesResponses[keyof ListGamesResponses];

export type CreateGameData = {
    body: CreateGameRequest;
    path?: never;
    query?: never;
    url: '/games';
};

export type CreateGameErrors = {
    /**
     * Bad request
     */
    400: ValidationError;
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Forbidden
     */
    403: _Error;
    /**
     * Internal server error
     */
    500: _Error;
};

export type CreateGameError = CreateGameErrors[keyof CreateGameErrors];

export type CreateGameResponses = {
    /**
     * Game created successfully
     */
    201: GameResponse;
};

export type CreateGameResponse = CreateGameResponses[keyof CreateGameResponses];

export type DeleteGameData = {
    body?: never;
    path: {
        /**
         * Game ID
         */
        id: string;
    };
    query?: never;
    url: '/games/{id}';
};

export type DeleteGameErrors = {
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Forbidden
     */
    403: _Error;
    /**
     * Resource not found
     */
    404: _Error;
    /**
     * Internal server error
     */
    500: _Error;
};

export type DeleteGameError = DeleteGameErrors[keyof DeleteGameErrors];

export type DeleteGameResponses = {
    /**
     * Game deleted successfully
     */
    200: {
        message?: string;
    };
};

export type DeleteGameResponse = DeleteGameResponses[keyof DeleteGameResponses];

export type GetGameData = {
    body?: never;
    path: {
        /**
         * Game ID
         */
        id: string;
    };
    query?: never;
    url: '/games/{id}';
};

export type GetGameErrors = {
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Forbidden
     */
    403: _Error;
    /**
     * Resource not found
     */
    404: _Error;
    /**
     * Internal server error
     */
    500: _Error;
};

export type GetGameError = GetGameErrors[keyof GetGameErrors];

export type GetGameResponses = {
    /**
     * Game retrieved successfully
     */
    200: GameResponse;
};

export type GetGameResponse = GetGameResponses[keyof GetGameResponses];

export type UpdateGameData = {
    body: UpdateGameRequest;
    path: {
        /**
         * Game ID
         */
        id: string;
    };
    query?: never;
    url: '/games/{id}';
};

export type UpdateGameErrors = {
    /**
     * Bad request
     */
    400: ValidationError;
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Forbidden
     */
    403: _Error;
    /**
     * Resource not found
     */
    404: _Error;
    /**
     * Internal server error
     */
    500: _Error;
};

export type UpdateGameError = UpdateGameErrors[keyof UpdateGameErrors];

export type UpdateGameResponses = {
    /**
     * Game updated successfully
     */
    200: GameResponse;
};

export type UpdateGameResponse = UpdateGameResponses[keyof UpdateGameResponses];

export type ListVideosData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Number of items to return (1-100)
         */
        limit?: number;
        /**
         * Token for pagination
         */
        nextToken?: string;
        /**
         * Sort order for results
         */
        sortOrder?: 'asc' | 'desc';
        /**
         * Filter by game ID (required for game-scoped access)
         */
        gameId?: string;
        /**
         * Filter by video type
         */
        videoType?: 'highlight' | 'full_game' | 'training' | 'interview' | 'analysis' | 'other';
        /**
         * Filter by video status
         */
        status?: 'processing' | 'ready' | 'failed' | 'archived';
        /**
         * Filter videos from this date
         */
        dateFrom?: string;
        /**
         * Filter videos until this date
         */
        dateTo?: string;
        /**
         * Search videos by title (partial match)
         */
        title?: string;
        /**
         * Filter by tags (comma-separated)
         */
        tags?: string;
    };
    url: '/videos';
};

export type ListVideosErrors = {
    /**
     * Bad request
     */
    400: ValidationError;
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Forbidden
     */
    403: _Error;
    /**
     * Internal server error
     */
    500: _Error;
};

export type ListVideosError = ListVideosErrors[keyof ListVideosErrors];

export type ListVideosResponses = {
    /**
     * Videos retrieved successfully
     */
    200: VideoListResponse;
};

export type ListVideosResponse = ListVideosResponses[keyof ListVideosResponses];

export type CreateVideoData = {
    body: CreateVideoRequest;
    path?: never;
    query?: never;
    url: '/videos';
};

export type CreateVideoErrors = {
    /**
     * Bad request
     */
    400: ValidationError;
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Forbidden
     */
    403: _Error;
    /**
     * Internal server error
     */
    500: _Error;
};

export type CreateVideoError = CreateVideoErrors[keyof CreateVideoErrors];

export type CreateVideoResponses = {
    /**
     * Video created successfully
     */
    201: VideoResponse;
};

export type CreateVideoResponse = CreateVideoResponses[keyof CreateVideoResponses];

export type DeleteVideoData = {
    body?: never;
    path: {
        /**
         * Video ID
         */
        id: string;
    };
    query?: never;
    url: '/videos/{id}';
};

export type DeleteVideoErrors = {
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Forbidden
     */
    403: _Error;
    /**
     * Resource not found
     */
    404: _Error;
    /**
     * Internal server error
     */
    500: _Error;
};

export type DeleteVideoError = DeleteVideoErrors[keyof DeleteVideoErrors];

export type DeleteVideoResponses = {
    /**
     * Video deleted successfully
     */
    200: {
        message?: string;
    };
};

export type DeleteVideoResponse = DeleteVideoResponses[keyof DeleteVideoResponses];

export type GetVideoData = {
    body?: never;
    path: {
        /**
         * Video ID
         */
        id: string;
    };
    query?: never;
    url: '/videos/{id}';
};

export type GetVideoErrors = {
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Forbidden
     */
    403: _Error;
    /**
     * Resource not found
     */
    404: _Error;
    /**
     * Internal server error
     */
    500: _Error;
};

export type GetVideoError = GetVideoErrors[keyof GetVideoErrors];

export type GetVideoResponses = {
    /**
     * Video retrieved successfully
     */
    200: VideoResponse;
};

export type GetVideoResponse = GetVideoResponses[keyof GetVideoResponses];

export type UpdateVideoData = {
    body: UpdateVideoRequest;
    path: {
        /**
         * Video ID
         */
        id: string;
    };
    query?: never;
    url: '/videos/{id}';
};

export type UpdateVideoErrors = {
    /**
     * Bad request
     */
    400: ValidationError;
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Forbidden
     */
    403: _Error;
    /**
     * Resource not found
     */
    404: _Error;
    /**
     * Internal server error
     */
    500: _Error;
};

export type UpdateVideoError = UpdateVideoErrors[keyof UpdateVideoErrors];

export type UpdateVideoResponses = {
    /**
     * Video updated successfully
     */
    200: VideoResponse;
};

export type UpdateVideoResponse = UpdateVideoResponses[keyof UpdateVideoResponses];

export type GetVideoSignedUrlData = {
    body?: never;
    path: {
        /**
         * Team ID
         */
        teamId: string;
        /**
         * Game ID
         */
        gameId: string;
    };
    query: {
        /**
         * Name of the file to upload
         */
        filename: string;
    };
    url: '/videos/teams/{teamId}/games/{gameId}/upload-url';
};

export type GetVideoSignedUrlErrors = {
    /**
     * Bad request
     */
    400: ValidationError;
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Forbidden
     */
    403: _Error;
    /**
     * Internal server error
     */
    500: _Error;
};

export type GetVideoSignedUrlError = GetVideoSignedUrlErrors[keyof GetVideoSignedUrlErrors];

export type GetVideoSignedUrlResponses = {
    /**
     * Signed URL generated successfully
     */
    200: VideoUploadUrlResponse;
};

export type GetVideoSignedUrlResponse = GetVideoSignedUrlResponses[keyof GetVideoSignedUrlResponses];

export type ProcessVideoData = {
    body?: never;
    path: {
        /**
         * Video ID
         */
        videoId: string;
    };
    query?: never;
    url: '/videos/{videoId}/process';
};

export type ProcessVideoErrors = {
    /**
     * Bad request
     */
    400: ValidationError;
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Forbidden
     */
    403: _Error;
    /**
     * Resource not found
     */
    404: _Error;
    /**
     * Internal server error
     */
    500: _Error;
};

export type ProcessVideoError = ProcessVideoErrors[keyof ProcessVideoErrors];

export type ProcessVideoResponses = {
    /**
     * Video processing started successfully
     */
    200: {
        message?: string;
        data?: {
            videoId?: string;
            jobId?: string;
            hlsPlaylistUrl?: string;
            mp4StreamUrl?: string;
            status?: string;
        };
    };
};

export type ProcessVideoResponse = ProcessVideoResponses[keyof ProcessVideoResponses];

export type CheckProcessingStatusData = {
    body?: never;
    path: {
        /**
         * Video ID
         */
        videoId: string;
    };
    query?: never;
    url: '/videos/{videoId}/processing-status';
};

export type CheckProcessingStatusErrors = {
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Forbidden
     */
    403: _Error;
    /**
     * Resource not found
     */
    404: _Error;
    /**
     * Internal server error
     */
    500: _Error;
};

export type CheckProcessingStatusError = CheckProcessingStatusErrors[keyof CheckProcessingStatusErrors];

export type CheckProcessingStatusResponses = {
    /**
     * Processing status retrieved successfully
     */
    200: {
        message?: string;
        data?: {
            videoId?: string;
            jobId?: string;
            jobStatus?: 'SUBMITTED' | 'PROGRESSING' | 'COMPLETE' | 'CANCELED' | 'ERROR';
            videoStatus?: 'processing' | 'ready' | 'failed';
            hlsPlaylistUrl?: string;
            mp4StreamUrl?: string;
            progress?: number;
            createdAt?: string;
            completedAt?: string;
        };
    };
};

export type CheckProcessingStatusResponse = CheckProcessingStatusResponses[keyof CheckProcessingStatusResponses];

export type UploadVideoFromUrlData = {
    body: UploadVideoFromUrlRequest;
    path?: never;
    query?: never;
    url: '/videos/upload-from-url';
};

export type UploadVideoFromUrlErrors = {
    /**
     * Bad request
     */
    400: ValidationError;
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Forbidden
     */
    403: _Error;
    /**
     * Internal server error
     */
    500: _Error;
};

export type UploadVideoFromUrlError = UploadVideoFromUrlErrors[keyof UploadVideoFromUrlErrors];

export type UploadVideoFromUrlResponses = {
    /**
     * Upload task started successfully
     */
    202: AsyncTaskResponse;
};

export type UploadVideoFromUrlResponse = UploadVideoFromUrlResponses[keyof UploadVideoFromUrlResponses];

export type ListAnalysesData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Number of items to return (1-100)
         */
        limit?: number;
        /**
         * Token for pagination
         */
        nextToken?: string;
        /**
         * Sort order for results
         */
        sortOrder?: 'asc' | 'desc';
        /**
         * Filter by video ID (required for video-scoped access)
         */
        videoId?: string;
        /**
         * Filter by analysis type
         */
        analysisType?: 'performance' | 'tactical' | 'technical' | 'emotional' | 'highlight_detection' | 'player_tracking' | 'event_detection' | 'statistics' | 'custom';
        /**
         * Filter by analysis status
         */
        status?: 'queued' | 'processing' | 'completed' | 'failed' | 'cancelled';
        /**
         * Filter by AI model name
         */
        modelName?: string;
        /**
         * Filter by AI model version
         */
        modelVersion?: string;
        /**
         * Filter analyses from this date
         */
        dateFrom?: string;
        /**
         * Filter analyses until this date
         */
        dateTo?: string;
        /**
         * Filter by who initiated the analysis
         */
        initiatedBy?: string;
        /**
         * Filter by minimum confidence score (0-1)
         */
        minConfidence?: number;
    };
    url: '/analyses';
};

export type ListAnalysesErrors = {
    /**
     * Bad request
     */
    400: ValidationError;
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Forbidden
     */
    403: _Error;
    /**
     * Internal server error
     */
    500: _Error;
};

export type ListAnalysesError = ListAnalysesErrors[keyof ListAnalysesErrors];

export type ListAnalysesResponses = {
    /**
     * Analyses retrieved successfully
     */
    200: AnalysisListResponse;
};

export type ListAnalysesResponse = ListAnalysesResponses[keyof ListAnalysesResponses];

export type CreateAnalysisData = {
    body: CreateAnalysisRequest;
    path?: never;
    query?: never;
    url: '/analyses';
};

export type CreateAnalysisErrors = {
    /**
     * Bad request
     */
    400: ValidationError;
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Forbidden
     */
    403: _Error;
    /**
     * Internal server error
     */
    500: _Error;
};

export type CreateAnalysisError = CreateAnalysisErrors[keyof CreateAnalysisErrors];

export type CreateAnalysisResponses = {
    /**
     * Analysis created successfully
     */
    201: AnalysisResponse;
};

export type CreateAnalysisResponse = CreateAnalysisResponses[keyof CreateAnalysisResponses];

export type DeleteAnalysisData = {
    body?: never;
    path: {
        /**
         * Analysis ID
         */
        id: string;
    };
    query?: never;
    url: '/analyses/{id}';
};

export type DeleteAnalysisErrors = {
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Forbidden
     */
    403: _Error;
    /**
     * Resource not found
     */
    404: _Error;
    /**
     * Internal server error
     */
    500: _Error;
};

export type DeleteAnalysisError = DeleteAnalysisErrors[keyof DeleteAnalysisErrors];

export type DeleteAnalysisResponses = {
    /**
     * Analysis deleted successfully
     */
    200: {
        message?: string;
    };
};

export type DeleteAnalysisResponse = DeleteAnalysisResponses[keyof DeleteAnalysisResponses];

export type GetAnalysisData = {
    body?: never;
    path: {
        /**
         * Analysis ID
         */
        id: string;
    };
    query?: never;
    url: '/analyses/{id}';
};

export type GetAnalysisErrors = {
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Forbidden
     */
    403: _Error;
    /**
     * Resource not found
     */
    404: _Error;
    /**
     * Internal server error
     */
    500: _Error;
};

export type GetAnalysisError = GetAnalysisErrors[keyof GetAnalysisErrors];

export type GetAnalysisResponses = {
    /**
     * Analysis retrieved successfully
     */
    200: AnalysisResponse;
};

export type GetAnalysisResponse = GetAnalysisResponses[keyof GetAnalysisResponses];

export type UpdateAnalysisData = {
    body: UpdateAnalysisRequest;
    path: {
        /**
         * Analysis ID
         */
        id: string;
    };
    query?: never;
    url: '/analyses/{id}';
};

export type UpdateAnalysisErrors = {
    /**
     * Bad request
     */
    400: ValidationError;
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Forbidden
     */
    403: _Error;
    /**
     * Resource not found
     */
    404: _Error;
    /**
     * Internal server error
     */
    500: _Error;
};

export type UpdateAnalysisError = UpdateAnalysisErrors[keyof UpdateAnalysisErrors];

export type UpdateAnalysisResponses = {
    /**
     * Analysis updated successfully
     */
    200: AnalysisResponse;
};

export type UpdateAnalysisResponse = UpdateAnalysisResponses[keyof UpdateAnalysisResponses];

export type GetVideoAnalysesData = {
    body?: never;
    path: {
        /**
         * Game ID
         */
        gameId: string;
        /**
         * Video ID
         */
        videoId: string;
    };
    query?: {
        /**
         * Filter by prompt type
         */
        promptType?: PromptType;
        /**
         * Filter by specific segment index
         */
        segmentIndex?: number;
        /**
         * Number of items to return (1-100)
         */
        limit?: number;
        /**
         * Token for pagination
         */
        nextToken?: string;
    };
    url: '/analyses/{gameId}/{videoId}';
};

export type GetVideoAnalysesErrors = {
    /**
     * Bad request
     */
    400: ValidationError;
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Forbidden
     */
    403: _Error;
    /**
     * Resource not found
     */
    404: _Error;
    /**
     * Internal server error
     */
    500: _Error;
};

export type GetVideoAnalysesError = GetVideoAnalysesErrors[keyof GetVideoAnalysesErrors];

export type GetVideoAnalysesResponses = {
    /**
     * Video analyses retrieved successfully
     */
    200: VideoAnalysisListResponse;
};

export type GetVideoAnalysesResponse = GetVideoAnalysesResponses[keyof GetVideoAnalysesResponses];

export type AnalyzeVideoData = {
    body?: never;
    path: {
        /**
         * Game ID
         */
        gameId: string;
        /**
         * Video ID
         */
        videoId: string;
    };
    query: {
        /**
         * Team ID for authorization
         */
        teamId: string;
        /**
         * JSON array of prompt types to run (allows A/B testing of different prompts)
         */
        promptTypes?: string;
        /**
         * Maximum number of segments to analyze (optional limit)
         */
        maxSegments?: number;
        /**
         * Gemini model to use for analysis
         */
        geminiModel?: 'gemini-1.5-flash' | 'gemini-1.5-pro';
    };
    url: '/analyses/{gameId}/{videoId}';
};

export type AnalyzeVideoErrors = {
    /**
     * Bad request
     */
    400: ValidationError;
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Forbidden
     */
    403: _Error;
    /**
     * Resource not found
     */
    404: _Error;
    /**
     * Internal server error
     */
    500: _Error;
};

export type AnalyzeVideoError = AnalyzeVideoErrors[keyof AnalyzeVideoErrors];

export type AnalyzeVideoResponses = {
    /**
     * Video analysis task created successfully
     */
    202: AsyncTaskResponse;
};

export type AnalyzeVideoResponse = AnalyzeVideoResponses[keyof AnalyzeVideoResponses];

export type PollTaskData = {
    body?: never;
    path: {
        /**
         * Task ID returned from async operation
         */
        taskId: string;
    };
    query?: never;
    url: '/tasks/{taskId}';
};

export type PollTaskErrors = {
    /**
     * Bad request
     */
    400: ValidationError;
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Task not found
     */
    404: _Error;
    /**
     * Internal server error
     */
    500: _Error;
};

export type PollTaskError = PollTaskErrors[keyof PollTaskErrors];

export type PollTaskResponses = {
    /**
     * Task status retrieved successfully
     */
    200: ({
        status: 'processing';
    } & TaskProcessing) | ({
        status: 'completed';
    } & TaskCompleted) | ({
        status: 'failed';
    } & TaskFailed);
};

export type PollTaskResponse = PollTaskResponses[keyof PollTaskResponses];

export type ClientOptions = {
    baseUrl: 'https://yz9121tvt1.execute-api.eu-west-1.amazonaws.com/prod/' | (string & {});
};